class TaskAPI {
    constructor() {
        this.localURL = 'http://localhost:3000/tareas';
        this.tasks = [];
        this.useLocalAPI = true; // Siempre usar la API local
    }
/* task api es para manejar la logica de la coneccion con 
con un contrutor que se crea cuando se inica une neva intancia de clase de la url
con un arreglo vacion para guardar las tareas que se ontienen, y se pone como t para que se usa la api  loca, siempre*/
    /* */
    async getAllTasks() {
        try {
            const response = await fetch(this.localURL);
            if (!response.ok) { //!response.ok si la respuesta NO fue exitosa, ! es el operador logico de negacion
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            this.tasks = await response.json();
            return [...this.tasks]; //[...this.tasks] es una forma de crear una copa superficialshallow copy para evitar modificar el principal
        } catch (error) {
            console.error('Error al obtener las tareas:', error);
            throw new Error('Error al conectar con el servidor');
        }
    } /* con el metdoso asincrono obtenenemos las tareas
    desde el servidor, usa fecht para hace un peticion htto a la url y await para que se espera la respues
    se verifica si fue exitosa .ok es t para estaodos http 200,299
    si hubo error da un error. y esa respuesta la ponemos en json y se guarda en tareas
    */

    async createTask(taskData) {
        try {
            const newTask = {
                ...taskData,
                createdAt: new Date().toISOString()
            };

            const response = await fetch(this.localURL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(newTask)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const createdTask = await response.json();
            
            // Actualizar cache local
            this.tasks.push(createdTask);
            
            return createdTask;
        } catch (error) {
            console.error('Error al crear la tarea:', error);
            throw new Error('Error al crear la tarea');
        }
    }/* logica de la creacion, usando el spread operator ... se crea un newtask copiando la data de taskdata
    y se guarda en un formato de fecha ISO
    luego se hace una peticionn http post a la url al macenada en this.localURL
    para crear, se indica que se envi el json, body convierte el objeto newtasj
    en una cada jaon con el metodo .stringify
    se valida si todo va bien
    con reonse.jsaon se convierte la respuesta del servidor que bede tener la id y demas datos del formato jason
    despues actualizo la cache local de tares con this.task para que se 
    a√±ada al arreglo, devuelvo la cadeda un con id asignado por el servidor
    manejo erroes por si ocurre un error en la conexion, peticon o convercion
    */

    async updateTask(id, taskData) {
        try {
            const updatedTask = {
                ...taskData,
                id: parseInt(id), // Asegurar que el ID sea n√∫mero
                updatedAt: new Date().toISOString()
            };

            const response = await fetch(`${this.localURL}/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(updatedTask)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            
            // Actualizar cache local inmediatamente
            const index = this.tasks.findIndex(task => task.id == id);
            if (index !== -1) {
                this.tasks[index] = result;
            }
            
            return result;
        } catch (error) {
            console.error('Error al actualizar la tarea:', error);
            throw new Error('Error al actualizar la tarea');
        }
    }
/* este etodo asincrono va a reccibir un id, un objeto con los datos nuevo de la tarea
creamo un nuevo objeto, se copian los datos de taskdata, se asgura quel el id se un numero con el merto parseInt(id)
que basicamente interpreta como un nmero entero, a√±ado un campo para actualizar fecha y hora actual para registrar la modificacion
envio una pecioncion al metodo put a la url con el id de la tarea que se va a actualizar
, remplaza el la tarea existente del servirdor con el contenido nuevo}valido su todo va bien
proceso la respuesya en json que contiene la version difnal de la tarea ya actualizada en el servidor
para la actulizacion del cache local, se busca la tares,  findIndex() en JavaScript se utiliza para encontrar el √≠ndice del primer elemento de un arreglo que cumpla con una condici√≥n
== es el operador de comparaci√≥n no estricta, tambi√©n llamado "igualdad d√©bil"
     intenta convertir autom√°ticamente los tipos si son diferentes antes de compararlos.
si el indice es diferente que -1 siginicia que se reeemplaza esa tarea con el resultado
actualizado
 !== es el operador de desigualdad estrictaCompara dos valores y devuelve true si son diferentes en tipo o en valor (sin conversi√≥n de tipos)
     */
    async deleteTask(id) {
        try {
            const response = await fetch(`${this.localURL}/${id}`, {
                method: 'DELETE'
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            // Actualizar cache local
            this.tasks = this.tasks.filter(task => task.id != id);
            
            return true;
        } catch (error) {
            console.error('Error al eliminar la tarea:', error);
            throw new Error('Error al eliminar la tarea');
        }
    }
/* metodo asincrono para eliminar una tarea, recibe un id
    hace una peticion http delete a la url con el id de la tarea que se va a eliminar
    se vericia si todo fe bien, actualizao el cacje
    Se filtra el arreglo this.tasks para eliminar la tarea cuyo id coincida con el proporcionado.
    != es el operador de desigualdad no estricta (tambi√©n llamado desigualdad d√©bil)
    */
    async loadInitialData() {
        try {
            console.log('Conectando con json-server...');
            await this.getAllTasks();
            console.log(`‚úÖ Conectado con json-server local - ${this.tasks.length} tareas cargadas`);
        } catch (error) {
            console.error('Error al conectar con json-server:', error);
            
            // Fallback: datos de ejemplo en memoria
            this.tasks = [
                {
                    id: 1,
                    titulo: 'Tarea de ejemplo 1',
                    descripcion: 'Esta es una tarea de ejemplo mientras no hay conexi√≥n con el servidor',
                    estado: 'pendiente',
                    responsable: 'Usuario',
                    prioridad: 'media',
                    createdAt: new Date().toISOString()
                },
                {
                    id: 2,
                    titulo: 'Tarea de ejemplo 2',
                    descripcion: 'Otra tarea de ejemplo',
                    estado: 'en progreso',
                    responsable: 'Usuario',
                    prioridad: 'alta',
                    createdAt: new Date().toISOString()
                }
            ];
            
            console.log('Cargadas tareas de ejemplo (sin conexi√≥n al servidor)');
            throw error; // Re-lanzar para que TaskManager pueda manejarlo
        }
    }

    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}/* esta metodo asincrono se encarga de cargar lo nicales al cargar la aplicacion
llama el metodo para obtener todoas la tares, se imprimecuantas se obtuvieron, y las cuenta cuantas son si falla se pasa al cacht
 y asigno un arreglo con dos tareas de ejemplo con las propiesdas tasks  
 throw interrumpe la ejecuci√≥n normal y lanza un error.

error es el objeto o valor que quieres lanzar (usualmente un objeto de tipo Error)
despues pongo un delay en milisegundos, que devuelve una promes para pausar
 Para pausar o retrasar la ejecuci√≥n as√≠ncrona sin bloquear el hilo principal.
*/

class TaskManager {
    constructor() {
        this.api = new TaskAPI();
        this.currentFilter = { estado: '', responsable: '', prioridad: '' };
        this.editingTaskId = null;
        this.taskToDelete = null;
        this.draggedTask = null; 
        this.init();
    }

    async init() {
        try {
            await this.api.loadInitialData();
            await this.loadTasks();
            this.setupEventListeners();
            this.setupDragAndDrop();
            this.loadTheme();
        } catch (error) {
            this.showNotification('Servidor no disponible. Usando datos de ejemplo.', 'warning');
            this.renderTasks(this.api.tasks);
            this.setupEventListeners();
            this.setupDragAndDrop();
            this.loadTheme();
        }
    }
/* 
creo una clase para centralizar la logica de la app, 
 carga datos, maneja filtros, ediciones, borrados y eventos del usuario
constructor() es un m√©todo especial dentro de una clase que se ejecuta autom√°ticamente cuando creas (instancias) un nuevo objeto de esa clase
async init() s el inicio de la aplicaci√≥n
Carga los datos iniciales desde la API (intenta servidor y si falla, carga datos de ejemplo) con await this.api.loadInitialData()

Luego llama a await this.loadTasks() para mostrar las tareas (probablemente con alg√∫n filtro o procesamiento)

Configura los eventos de interacci√≥n (clicks, formularios, botones, etc.) con setupEventListeners()

Configura la funcionalidad de drag & drop con setupDragAndDrop()

Carga el tema visual o estilo preferido con loadTheme()

En caso de que falle la carga inicial (catch
    */

    async loadTasks() {
        try {
            this.showLoading();
            const tasks = await this.api.getAllTasks();
            this.renderTasks(tasks);
            this.updateFilters();
        } catch (error) {
            this.showNotification('Error al cargar las tareas', 'error');
            // Mostrar tareas en cache si falla la recarga
            this.renderTasks(this.api.tasks);
        } finally {
            this.hideLoading();
        }
    }
/* 
este metodo asincrono se encarga de cargar las tareas desde la api en la interfaz
this.showLoading()
Muestra un indicador visual (spinner, barra, texto, etc.) para informar al usuario que la carga est√° en proceso
const tasks = await this.api.getAllTasks();
Llama al m√©todo getAllTasks() de la instancia TaskAPI
Esta funci√≥n se conecta al servidor para obtener todas las tareas
this.renderTasks(tasks)  en la interfaz
this.updateFilters();
Actualiza los filtros visuales o de estado de la interfaz seg√∫n las tareas cargadas
this.hideLoading();
Se ejecuta siempre, haya habido √©xito o error
Oculta el indicador de carga para mostrar la interfaz lista para interactuar    */

    renderTasks(tasks = null) {
        const tasksToRender = tasks || this.api.tasks;
        const filteredTasks = this.filterTasks(tasksToRender);
        
        // Limpiar columnas
        ['pendiente', 'en progreso', 'terminada'].forEach(estado => {
            const container = document.getElementById(`tasks-${estado}`);
            if (container) container.innerHTML = '';
        });

        // Agrupar por estado
        const tasksByStatus = {
            'pendiente': filteredTasks.filter(task => task.estado === 'pendiente'),
            'en progreso': filteredTasks.filter(task => task.estado === 'en progreso'),
            'terminada': filteredTasks.filter(task => task.estado === 'terminada')
        };

        // Renderizar cada grupo
        Object.entries(tasksByStatus).forEach(([estado, statusTasks]) => {
            const container = document.getElementById(`tasks-${estado}`);
            const countElement = document.getElementById(`count-${estado}`);
            
            if (countElement) countElement.textContent = statusTasks.length;
            
            if (container) {
                statusTasks.forEach(task => {
                    container.appendChild(this.createTaskCard(task));
                });
            }
        });

        // Reconfigurar drag and drop despu√©s de renderizar
        this.setupDragAndDrop();
    }
/* 
este metodos va recirivi un arreglo de tareas o null, si es null se usa el arreglo de tareas de la api
aqui obtiene las tareas o las de la lista almacenada
luego filtro las tareas con el metodo filterTasks()
limpiar las columnas de la ui para mostras las tareas agrupas
lo limpio para evitar acumulacion de tareas vienas en el html
creo un objeto donde cada propiedad es un estado que tiene un arreglo con las tareas del dichoso estado
Object.entries() va a renderizar por gurpo
se obtiene el contenedor de tares un un elemenato para mostrar el conteo
appendChild es un m√©todo en JavaScript que se usa para agregar un nodo (elemento, texto, etc.) como hijo al final de otro nodo en el DOM 
Crea din√°micamente una "tarjeta" o representaci√≥n visual de una tarea y la agrega al contenedor para que se muestre en la p√°gina.
   this.setupDragAndDrop();
    renderizar, vuelve a configurar el sistema de arrastrar y soltar, porque el DOM cambi√≥
*/
    createTaskCard(task) {
        const card = document.createElement('div');
        card.className = 'task-card';
        card.draggable = true;
        card.dataset.taskId = task.id;
        
        const priorityClass = task.prioridad || 'media';
        
        card.innerHTML = `
            <div class="task-header">
                <h3 class="task-title">${this.escapeHtml(task.titulo)}</h3>
                <div class="task-actions">
                    <button class="task-btn edit-btn" data-id="${task.id}" title="Editar">‚úèÔ∏è</button>
                    <button class="task-btn delete-btn" data-id="${task.id}" title="Eliminar">üóëÔ∏è</button>
                </div>
            </div>
            <p class="task-description">${this.escapeHtml(task.descripcion)}</p>
            <div class="task-footer">
                <span class="task-responsible">üë§ ${this.escapeHtml(task.responsable)}</span>
                <span class="priority-badge priority-${priorityClass}">${priorityClass.toUpperCase()}</span>
            </div>
        `;
/* 
crear un div con toda la informaci√≥n y controles visuales de una tarea, con soporte para drag & drop, edici√≥n y eliminaci√≥n.
crea un div visual que sera la pargeta en card, le asigana una clase para el css
con t hace que se pueda arratrar, y se lamacena el ID
dtermina la prioridad de la clase, si no tiene se le pone media como predeterminado
.escapeHtml es un m√©todo que escapa caracteres especiales para evitar inyecciones de HTML
 Convertir caracteres especiales (como <, >, ", ', &) a sus equivalentes seguros para que no se interpreten como HTML cuando los insertas en el DOM.  
 .stopPropagation() es un m√©todo del objeto Event en JavaScript que detiene la propagaci√≥n del evento por la cadena de elementos del DOM
 el evento no se seguir√° enviando a los elementos padres
 */
        card.querySelector('.edit-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            this.editTask(task.id);
        });

        card.querySelector('.delete-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            this.showDeleteConfirm(task.id);
        });

        return card;
    }
/* 
filtra las tareas seg√∫n los criterios actuales de b√∫squeda establecidos en this.currentFilter, y devuelve solo las que coinciden
Son del mismo tipo, y Tienen el mismo valor
estadoMatch:
Si this.currentFilter.estado est√° vac√≠o, coincide con todos.
Si est√° definido (por ejemplo "pendiente"), compara con task.estado.
responsableMatch:
Si this.currentFilter.responsable est√° vac√≠o, coincide con todos.
Si no, busca que el nombre del responsable contenga (de forma insensible a may√∫sculas/min√∫sculas) lo escrito.
prioridadMatch:
Similar a estadoMatch, pero con el campo prioridad.
*/
    filterTasks(tasks) {
        return tasks.filter(task => {
            const estadoMatch = !this.currentFilter.estado || task.estado === this.currentFilter.estado;
            const responsableMatch = !this.currentFilter.responsable || 
                task.responsable.toLowerCase().includes(this.currentFilter.responsable.toLowerCase());
            const prioridadMatch = !this.currentFilter.prioridad || task.prioridad === this.currentFilter.prioridad;
            
            return estadoMatch && responsableMatch && prioridadMatch;
        });
    }
/* 
controla el flujo completo para crear una nueva tarea desde la interfaz
muestra una animaci√≥n de carga, llama al API, recarga las tareas y da retroalimentaci√≥n al usuario
    */
    async createTask(taskData) {
        try {
            this.showLoading();
            await this.api.createTask(taskData);
            this.showNotification('Tarea creada exitosamente', 'success');
            await this.loadTasks();
            this.resetForm();
        } catch (error) {
            this.showNotification('rror al crear la tarea: ' + error.message, 'error');
        } finally {
            this.hideLoading();
        }
    }
/* 

m√©todo se encarga de actualizar una tarea existente usando la API y luego reflejar ese cambio en la interfaz

    */
    async updateTask(id, taskData) {
        try {
            this.showLoading();
            await this.api.updateTask(id, taskData);
            // Llama al m√©todo del API que actualiza la tarea en json-server
            this.showNotification('Tarea actualizada exitosamente', 'success');
            await this.loadTasks();
            this.resetForm();
            this.editingTaskId = null;
             // Indica que ya no se est√° editando ninguna tarea
        } catch (error) {
            this.showNotification('Error al actualizar la tarea: ' + error.message, 'error');
        } finally {
            this.hideLoading();
        }
    }
/* 
se encarga de eliminar una tarea espec√≠fica por su ID
    */
    async deleteTask(id) {
        try {
            this.showLoading();
            await this.api.deleteTask(id);
            this.showNotification('Tarea eliminada exitosamente', 'success');
            await this.loadTasks();
        } catch (error) {
            this.showNotification(' Error al eliminar la tarea: ' + error.message, 'error');
        } finally {
            this.hideLoading();
        }
    }
/* 
Este m√©todo moveTask(taskId, newState) de la clase TaskManager se encarga de mover una tarea a un nuevo estado

    */

    async moveTask(taskId, newState) {
        const task = this.api.tasks.find(t => t.id == taskId);
        if (!task || task.estado === newState) return;

        const originalState = task.estado;
        
        try {
            // Actualizar UI inmediatamente 
            this.updateTaskStateInUI(taskId, newState);
            
            // Actualizar en el servidor
            const updatedTask = { ...task, estado: newState };
            await this.api.updateTask(taskId, updatedTask);
            
            this.showNotification(`Tarea movida a "${newState}"`, 'success');
            
            // Recargar para sincronizar con el servidor
            setTimeout(() => this.renderTasks(), 500);
            
        } catch (error) {
            // Revertir cambios en caso de error
            this.updateTaskStateInUI(taskId, originalState);
            console.error('Error al mover tarea:', error);
            this.showNotification('Error al mover la tarea', 'error');
        }
    }
/* 
Actualizar inmediatamente la interfaz visual para reflejar el cambio de estado de una tarea, sin esperar a la respuesta del servidor
usca en el DOM el elemento que representa la tarjeta de la tarea mediante el atributo personalizado data-task-id igual al ID de la tarea
Actualizar tarea en cache local
Busca la columna HTML correspondiente al nuevo estad, si existe se crear una nueva targeta en esa columna
Actualiza los contadores visuales que indican cu√°ntas tareas hay en cada columna
    */

    updateTaskStateInUI(taskId, newState) {
        const taskCard = document.querySelector(`[data-task-id="${taskId}"]`);
        if (taskCard) {
            // Remover de la columna actual
            taskCard.remove();
            
            const taskIndex = this.api.tasks.findIndex(t => t.id == taskId);
            if (taskIndex !== -1) {
                this.api.tasks[taskIndex].estado = newState;
                
                const newContainer = document.getElementById(`tasks-${newState}`);
                if (newContainer) {
                    newContainer.appendChild(this.createTaskCard(this.api.tasks[taskIndex]));
                }
            }
            
            this.updateColumnCounts();
        }
    }
/* 
Actualizar los contadores visibles que indican cu√°ntas tareas hay en cada columna de estado
   Cuenta cu√°ntos hijos tiene el contenedor, es decir, cu√°ntas tarjetas de tarea est√°n dentro (cada tarea es un hijo)
  Actualiza el texto del contador para mostrar el n√∫mero actual  
*/
    // Actualizar contadores de columnas
    updateColumnCounts() {
        ['pendiente', 'en progreso', 'terminada'].forEach(estado => {
            const container = document.getElementById(`tasks-${estado}`);
            const countElement = document.getElementById(`count-${estado}`);
            
            if (container && countElement) {//Asegura que ambos elementos existan en el DOM antes de procede
                const count = container.children.length;
                countElement.textContent = count;
            }
        });
    }
/* 
Preparar la interfaz para editar una tarea existente, llenando un formulario
con los datos actuales de la tarea y 
ajustando botones para que el usuario pueda actualizarla o cancelar
Resetea la variable editingTaskId a null, indicando que ya no hay ninguna tarea en edici√≥n
Mostrar un modal (ventana emergente) para confirmar la eliminaci√≥n de una tarea
    async confirmDelete()  Confirmar y ejecutar la eliminaci√≥n de una tarea
*/
    editTask(id) {
        const task = this.api.tasks.find(t => t.id == id);
        if (!task) return;//Si no existe esa tarea, no hace nada y termina.

        const form = document.getElementById('taskForm');
        if (form) {
            document.getElementById('titulo').value = task.titulo;
            document.getElementById('descripcion').value = task.descripcion;
            document.getElementById('estado').value = task.estado;
            document.getElementById('responsable').value = task.responsable;
            document.getElementById('prioridad').value = task.prioridad || 'media';

            // Cambiar el bot√≥n, osea Obtiene los botone
            const submitBtn = document.getElementById('submitBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            
            if (submitBtn) {//Cambia el texto del bot√≥n enviar para que diga ‚ÄúActualizar Tarea‚Äù
                submitBtn.textContent = 'Actualizar Tarea';
                submitBtn.className = 'btn btn-secondary';
            }
            
            if (cancelBtn) {
                cancelBtn.style.display = 'block';
            }

            this.editingTaskId = id;

            form.scrollIntoView({ behavior: 'smooth' });
        }
    }
    cancelEdit() {
        this.editingTaskId = null;
        this.resetForm();
    }

    showDeleteConfirm(id) {
        this.taskToDelete = id;
        const modal = document.getElementById('confirmModal');
        if (modal) {
            modal.classList.add('show');
        }
    }

    hideModal() {
        const modal = document.getElementById('confirmModal');
        if (modal) {
            modal.classList.remove('show');
        }
        this.taskToDelete = null;
    }

    async confirmDelete() {
        if (this.taskToDelete) {
            await this.deleteTask(this.taskToDelete);
            this.hideModal();
        }
    }
/* 
se limpia y resetea el formulario para una nueva tarea
cambio el boton para que digra crear tarea
oculto el botno eliminar qeu solo aparece cuando se edita una tarea
 Reinicia la variable que indica si est√°s editando alguna tarea, p
 orque ahora no se est√° editando ninguna
    */
    resetForm() {
        const form = document.getElementById('taskForm');
        if (form) {
            form.reset();
            
            const submitBtn = document.getElementById('submitBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            
            if (submitBtn) {
                submitBtn.textContent = 'Crear Tarea';
                submitBtn.className = 'btn btn-primary';
            }
            
            if (cancelBtn) {
                cancelBtn.style.display = 'none';
            }
            
            this.editingTaskId = null;
        }
    }
/* 
actualiza el filtro de responsables en el 
DOM bas√°ndose en las tareas cargadas
usamo set para obtener una lista unica de responsables sin duplicados
Crea un elemento <select> con opciones para cada responsable encontrado
con una opci√≥n por defecto
    */
    updateFilters() {
        const responsables = [...new Set(this.api.tasks.map(task => task.responsable))];
        const select = document.getElementById('filterResponsible');
        
        if (select) {
            select.innerHTML = '<option value="">Todos los responsables</option>';
            responsables.forEach(responsable => {
                const option = document.createElement('option');
                option.value = responsable;
                option.textContent = responsable;
                select.appendChild(option);
            });
        }
    }
/* 
applyFilters() lee los valores seleccionados en los 
filtros y actualiza el filtro activo para las tareas
this.currentFilter es un objeto que asigna los calores de filtro
? es el operador ternario condici√≥n ? valor_si_verdadero : valor_si_falso;
Si responsableFilter existe (es decir, no es null, undefined, false, 0, etc.),
‚Üí entonces usa responsableFilter.value.
Si no existe,
‚Üí usa la cadena vac√≠a ''
    */
    applyFilters() {
        const responsableFilter = document.getElementById('filterResponsible');
        const prioridadFilter = document.getElementById('filterPriority');
        const estadoFilter = document.getElementById('filterStatus');

        this.currentFilter = {
            responsable: responsableFilter ? responsableFilter.value : '',
            prioridad: prioridadFilter ? prioridadFilter.value : '',
            estado: estadoFilter ? estadoFilter.value : ''
        };

        this.renderTasks();//Re-renderiza la lista de tareas aplicando los nuevos filtros
    }
/* 
restablece todos los filtros a su valor por defecto (vac√≠o)
    */
    clearFilters() {
        const filters = ['filterResponsible', 'filterPriority', 'filterStatus'];
        filters.forEach(filterId => {
            const element = document.getElementById(filterId);
            if (element) element.value = '';
        });
        
        this.currentFilter = { estado: '', responsable: '', prioridad: '' };
        this.renderTasks();
    }
/* 
el sistema de arrastrar y soltar (Drag & Drop) para mover tareas entre columnas
setupDragAndDrop() inicia todo el ssitema de drag and droppor tareas
primero remuevo liteners anterios paraevitar duplicados, selecciono
columnas y targetas, yacrego listenrs
para columnas y targetas y prevenir comportamiento por fedecto: 
dragover Permitir que un elemento sea un destino v√°lido para soltar
dragenter Aplicar un estilo visual temporal (por ejemplo, un borde de color) para indicar que el √°rea acepta el elemento
dragleave Cuando el elemento arrastrado sale del contenedor sin ser soltado
dragstart, dragend;   Cuando empieza a arrastrarse un elemento
  Cuando se suelta el elemento (ya sea exitosamente o no)
.classList es una propiedad de los elementos HTML que te permite manipular sus clases CSS
*/
    setupDragAndDrop() {
        this.removeDragListeners();
        
        const columns = document.querySelectorAll('.tasks-container');
        const taskCards = document.querySelectorAll('.task-card');
        
        // Configurar zonas de drop (columnas)
        columns.forEach(column => {
            column.addEventListener('dragover', this.handleDragOver.bind(this));
            column.addEventListener('dragenter', this.handleDragEnter.bind(this));
            column.addEventListener('dragleave', this.handleDragLeave.bind(this));
            column.addEventListener('drop', this.handleDrop.bind(this));
        });

        // Configurar elementos arrastrables (tarjetas)
        taskCards.forEach(card => {
            card.addEventListener('dragstart', this.handleDragStart.bind(this));
            card.addEventListener('dragend', this.handleDragEnd.bind(this));
        });

        console.log(`Drag & Drop configurado para ${taskCards.length} tareas`);
    }
// Manejo de eventos de drag & drop
    handleDragStart(e) {
        if (e.target.classList.contains('task-card')) {
            this.draggedTask = e.target;
            e.target.classList.add('dragging');//Le agrega la clase .dragging
            e.dataTransfer.setData('text/plain', e.target.dataset.taskId);// setrasdiere el id de la tarea
            e.dataTransfer.effectAllowed = 'move';
            
            // Agregar feedback visual, a todas las columnas, fuerza al dom a re-renderizar
            setTimeout(() => {
                const columns = document.querySelectorAll('.tasks-container');
                columns.forEach(col => col.classList.add('drag-active'));
            }, 0);
        }
    }

    handleDragEnd(e) {//Se ejecuta al soltar o cancelar el arrastre
        if (e.target.classList.contains('task-card')) {
            e.target.classList.remove('dragging');
            this.draggedTask = null;
            
            // Remover feedback visual
            const columns = document.querySelectorAll('.tasks-container');
            columns.forEach(col => {
                col.classList.remove('drag-active', 'drop-zone', 'active');
            });
        }
    }

    handleDragOver(e) {// Evita el comportamiento por defecto del navegador
        e.preventDefault();//bloquea la acci√≥n autom√°tica que el navegador har√≠a normalmente
        e.dataTransfer.dropEffect = 'move';
    }

    handleDragEnter(e) {//Se ejecuta al soltar o cancelar el arrastre
        e.preventDefault();
        if (e.currentTarget.classList.contains('tasks-container')) {
            e.currentTarget.classList.add('drop-zone', 'active');
        }
    }
//handleDragEnter(e):Se activa al entrar en una columna con un elemento arrastrado
//handleDragLeave(e)Se activa al salir del √°rea de una columna

    handleDragLeave(e) {
        // Solo remover si realmente salimos del contenedor
        if (!e.currentTarget.contains(e.relatedTarget)) {
            e.currentTarget.classList.remove('drop-zone', 'active');
        }
        /* 
handleDragLeave(e) est√° bien dise√±ado para evitar eliminar estilos de zona activa si a√∫n estamos dentro de la columna, 
lo cual es importante para evitar "parpadeos visuales"
    */
    }
/* 
handleDrop(e); limpia los estilos vizuales
estrear el taskid u el nuevo estado de la traformacion
llama a movetask para sincronizar la ui y el servidor
Busca la primera ocurrencia del texto 'tasks-' dentro del string y la reemplaza por '' (cadena vac√≠a).
Es decir, elimina el texto 'tasks-' del string
    */
    async handleDrop(e) {
        e.preventDefault();
        const column = e.currentTarget;
        column.classList.remove('drop-zone', 'active');
        
        const taskId = e.dataTransfer.getData('text/plain');
        const newState = column.id.replace('tasks-', '');
        
        if (taskId && newState) {
            console.log(`Moviendo tarea ${taskId} a estado: ${newState}`);
            await this.moveTask(taskId, newState);
        }
    }
/* 
Remover listeners anteriores para evitar duplicados
    */
    removeDragListeners() {
        const columns = document.querySelectorAll('.tasks-container');
        const taskCards = document.querySelectorAll('.task-card');
        
        columns.forEach(column => {
            column.classList.remove('drag-active', 'drop-zone', 'active');
        });
        
        taskCards.forEach(card => {
            card.classList.remove('dragging');
        });
    }
/* 
alternar entre modo oscuro y claro, y adem√°s guarda la preferencia en sessionStorage

    */
    toggleTheme() {
        document.body.classList.toggle('dark-theme');
        const isDark = document.body.classList.contains('dark-theme');
        const themeBtn = document.getElementById('themeToggle');
        
        if (themeBtn) {//verifica si esites, y se camvia el texto biblise en el html
            themeBtn.textContent = isDark ? ' Modo Claro' : 'Modo Oscuro';
        }
        
        // Guardar preferencia en sessionStorage
        sessionStorage.setItem('darkTheme', isDark);
    }

    loadTheme() {
        const isDark = sessionStorage.getItem('darkTheme') === 'true';
        if (isDark) {
            document.body.classList.add('dark-theme');
            const themeBtn = document.getElementById('themeToggle');
            if (themeBtn) {
                themeBtn.textContent = 'Modo Claro';
            }
        }
    }
/* 
sessionStorage se borra al cerrar la pesta√±a
Recupera un valor guardado en sessionStorage bajo la clave 'darkTheme'
ocument.body.classList.add('dark-theme');
Agrega la clase CSS 
const themeBtn = document.getElementById('themeToggle');
Busca en el DOM un elemento con id 'themeToggle'
if (themeBtn) { themeBtn.textContent = 'Modo Claro'; }
Si el bot√≥n existe, cambia su texto visible a 'Modo Claro'
    */
    showNotification(message, type) {
        const notification = document.getElementById('notification');
        if (notification) {
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        } else {
            // Fallback si no existe el elemento notification
            console.log(`${type.toUpperCase()}: ${message}`);
        }
    }
/* 
ostrar un indicador de carga centrado
1. Buscar un contenedor para el tablero de tareas.
rimero intenta obtener el elemento con id 'task-board'.
Si no existe, busca el primer elemento con clase 'board'.
2. Verificar que exista el contenedor y que no haya ya un elemento con clase 'loading' en el DOM,
para evitar crear m√∫ltiples indicadores de carga simult√°neos
3. Crear un nuevo elemento <div> que ser√° el indicador de carga
 4. Asignar la clase CSS
 Insertar contenido HTML dentro del div con el texto "Cargando...".
  Definir estilos CSS 
  agregar el elemento cargador como hijo del body del documento,
ra que sea visible al usuario.
    */
    showLoading() {
        const board = document.getElementById('task-board') || document.querySelector('.board');
        if (board && !document.querySelector('.loading')) {
            const loading = document.createElement('div');
            loading.className = 'loading';
            loading.innerHTML = 'Cargando...';
            loading.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 20px;
                border-radius: 8px;
                z-index: 1000;
                font-size: 16px;
            `;
            document.body.appendChild(loading);
        }
    }

    hideLoading() {
        const loading = document.querySelector('.loading');
        if (loading) loading.remove();
    }

    escapeHtml(text) {//Esto es una forma segura de escapar caracteres especiales que pueden causar problemas o vulnerabilidades si se insertan directamente en HTML
        const div = document.createElement('div');// convierte < en &lt;, > en &gt;, etc.
        div.textContent = text;
        return div.innerHTML;
    }//Evita ataques de tipo XSS (inyecci√≥n de c√≥digo malicioso)
/* 
Este m√©todo registra todos los listeners de eventos necesarios 
para que la interfaz del sistema funcione correctamente
    */
    setupEventListeners() {
        // Formulario de tareas:Escucha el evento de env√≠o del formulario para crear o actualizar tareas
        const taskForm = document.getElementById('taskForm');
        if (taskForm) {
            taskForm.addEventListener('submit', (e) => this.handleFormSubmit(e));
        }

        // Bot√≥n cancelar: Si el usuario est√° editando una tarea y presiona "Cancelar", se limpia el formulario 
        const cancelBtn = document.getElementById('cancelBtn');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => this.cancelEdit());
        }

        // Bot√≥n de tema
        const themeToggle = document.getElementById('themeToggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => this.toggleTheme());
        }

        // Filtros: Cuando el usuario cambia el valor de los filtros, se aplica la l√≥gica
        const filterResponsible = document.getElementById('filterResponsible');
        if (filterResponsible) {
            filterResponsible.addEventListener('change', () => this.applyFilters());
        }

        const filterPriority = document.getElementById('filterPriority');
        if (filterPriority) {
            filterPriority.addEventListener('change', () => this.applyFilters());
        }

        const filterStatus = document.getElementById('filterStatus');
        if (filterStatus) {
            filterStatus.addEventListener('change', () => this.applyFilters());
        }

        const clearFilters = document.getElementById('clearFilters');
        if (clearFilters) {
            clearFilters.addEventListener('click', () => this.clearFilters());
        }

        // Botones del modal de confirmaci√≥n
        const modalClose = document.getElementById('confirmCancel');
        if (modalClose) {
            modalClose.addEventListener('click', () => this.hideModal());
        }

        const modalConfirm = document.getElementById('confirmDelete');
        if (modalConfirm) {
            modalConfirm.addEventListener('click', () => this.confirmDelete());
        }

        // Cerrar modal con Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.hideModal();
            }
        });

        // Cerrar modal al hacer clic fuera: (sobre el fondo del modal), se cierra el modal
        const confirmModal = document.getElementById('confirmModal');
        if (confirmModal) {
            confirmModal.addEventListener('click', (e) => {
                if (e.target.id === 'confirmModal') {
                    this.hideModal();
                }
            });
        }
    }
// recoger los datos del formulario, validarlos, y decidir si crea una nueva tarea o actualiza una existente
    handleFormSubmit(e) {
        e.preventDefault();
        
        const formData = new FormData(e.target);//targetea un elemento especifico del dom
        const taskData = {
            titulo: formData.get('titulo').trim(),
            descripcion: formData.get('descripcion').trim(),
            estado: formData.get('estado'),
            responsable: formData.get('responsable').trim(),
            prioridad: formData.get('prioridad') || 'media'
        };

        // Validaciones
        if (!this.validateTaskData(taskData)) {
            return;
        }

        if (this.editingTaskId) {
            // Actualizar tarea existente
            this.updateTask(this.editingTaskId, taskData);
        } else {
            // Crear nueva tarea
            this.createTask(taskData);
        }
    }
//&& || son operadores l√≥gicos en JavaScript. Se usa el operador || (OR) porque basta que una de las condiciones sea verdadera para considerar 
    validateTaskData(data) {
        const errors = [];

        if (!data.titulo || data.titulo.length < 3) {
            errors.push('El t√≠tulo debe tener al menos 3 caracteres');
        }

        if (data.titulo && data.titulo.length > 100) {
            errors.push('El t√≠tulo no puede exceder 100 caracteres');
        }

        if (!data.descripcion || data.descripcion.length < 10) {
            errors.push('La descripci√≥n debe tener al menos 10 caracteres');
        }

        if (data.descripcion && data.descripcion.length > 500) {
            errors.push('La descripci√≥n no puede exceder 500 caracteres');
        }

        if (!data.responsable || data.responsable.length < 2) {
            errors.push('El responsable debe tener al menos 2 caracteres');
        }

        if (data.responsable && data.responsable.length > 50) {
            errors.push('El responsable no puede exceder 50 caracteres');
        }

        if (errors.length > 0) {
            this.showNotification('‚ùå ' + errors.join('. '), 'error');
            return false;
        }

        return true;
    }
}

//Este evento se dispara cuando todo el HTML ha sido completamente cargado y procesado
document.addEventListener('DOMContentLoaded', () => {
    window.taskManager = new TaskManager();
});//window.taskManager: Guarda una instancia en el objeto global window, lo que la hace accesible desde la consola del navegador o desde cualquier otro script
//Se guarda una instancia de TaskManager en window.taskManager
// Exportar para uso global
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { TaskManager, TaskAPI };
}
// es una comprobaci√≥n com√∫n en JavaScript para hacer que un archivo funcione tanto en Node.js como en el navegador
//typeof module !== 'undefined' Esto evita errores si el script se ejecuta en un navegador
//{ TaskManager, TaskAPI }Est√° exportando esos dos objetos para que puedan ser usados en otros archivos de Node.js.